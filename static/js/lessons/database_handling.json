{
    "title": "Database Handling",
    "content": "<h2>Introduction to Databases</h2><p>Databases are organized collections of structured information or data, typically stored electronically in a computer system. They are essential for modern applications, providing efficient data storage, retrieval, and management capabilities.</p><h3>1. Types of Databases</h3><ul><li><strong>Relational Databases (RDBMS)</strong>: Store data in tables with rows and columns (e.g., MySQL, PostgreSQL)</li><li><strong>NoSQL Databases</strong>: Store data in various formats like documents, key-value pairs (e.g., MongoDB, Redis)</li><li><strong>Object-Oriented Databases</strong>: Store data as objects (e.g., ObjectDB)</li><li><strong>Graph Databases</strong>: Store data in nodes and edges (e.g., Neo4j)</li></ul><h3>2. Key Database Concepts</h3><h4>Basic Terms</h4><ul><li><strong>Table/Relation</strong>: A collection of related data entries consisting of rows and columns</li><li><strong>Record/Row</strong>: A single entry in a table</li><li><strong>Field/Column</strong>: A specific piece of information in a table</li><li><strong>Primary Key</strong>: Unique identifier for each record</li><li><strong>Foreign Key</strong>: References primary key in another table</li></ul><h4>Database Operations (CRUD)</h4><ul><li><strong>Create</strong>: Insert new records into the database</li><li><strong>Read</strong>: Retrieve or read existing records</li><li><strong>Update</strong>: Modify existing records</li><li><strong>Delete</strong>: Remove existing records</li></ul><h3>3. Database Design Principles</h3><h4>Normalization</h4><p>Normalization is the process of organizing data to reduce redundancy and improve data integrity. The main normal forms are:</p><ul><li><strong>First Normal Form (1NF)</strong>: Eliminate repeating groups</li><li><strong>Second Normal Form (2NF)</strong>: Remove partial dependencies</li><li><strong>Third Normal Form (3NF)</strong>: Remove transitive dependencies</li></ul><h4>Relationships</h4><ul><li><strong>One-to-One</strong>: One record in table A relates to one record in table B</li><li><strong>One-to-Many</strong>: One record in table A relates to many records in table B</li><li><strong>Many-to-Many</strong>: Many records in table A relate to many records in table B</li></ul><h3>4. Database Management</h3><h4>Important Aspects</h4><ul><li><strong>Security</strong>: User authentication, access control, encryption</li><li><strong>Backup and Recovery</strong>: Regular backups, disaster recovery plans</li><li><strong>Performance</strong>: Query optimization, indexing, caching</li><li><strong>Scalability</strong>: Handling growing data and user loads</li></ul><h3>5. Python Database Integration</h3><p>Python provides various libraries for database integration:</p><ul><li><strong>MySQL Connector</strong>: For MySQL databases</li><li><strong>psycopg2</strong>: For PostgreSQL databases</li><li><strong>sqlite3</strong>: For SQLite databases</li><li><strong>pymongo</strong>: For MongoDB databases</li></ul>",
    "exercises": [
        {
            "title": "Database Schema Design",
            "description": "Design a database schema for a library management system. The system should track books, authors, members, and borrowing records. Include appropriate tables, relationships, and constraints.",
            "hint": "Think about the relationships between entities (books-authors, members-books) and what information needs to be stored for each entity.",
            "startingCode": "# Example table creation statements\n\n# Authors table\nCREATE TABLE authors (\n    author_id INT PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    birth_date DATE,\n    nationality VARCHAR(50)\n);\n\n# Books table\nCREATE TABLE books (\n    book_id INT PRIMARY KEY,\n    title VARCHAR(200) NOT NULL,\n    # Add more fields and constraints\n);\n\n# Members table\nCREATE TABLE members (\n    member_id INT PRIMARY KEY,\n    # Add appropriate fields\n);\n\n# Borrowing records table\nCREATE TABLE borrowings (\n    borrowing_id INT PRIMARY KEY,\n    # Add fields and foreign key constraints\n);\n\n# Add necessary relationships and constraints"
        },
        {
            "title": "Query Analysis",
            "description": "Given a set of database queries, analyze their performance implications and suggest improvements. Consider indexing, join operations, and query optimization techniques.",
            "hint": "Look for full table scans, inefficient joins, and missing indexes. Consider how the query execution plan could be improved.",
            "startingCode": "# Example queries to analyze\n\n# Query 1: Finding all books borrowed by a member\nSELECT b.title, br.borrow_date\nFROM books b\nJOIN borrowings br ON b.book_id = br.book_id\nWHERE br.member_id = 123;\n\n# Query 2: List of authors and their book count\nSELECT a.name, COUNT(b.book_id) as book_count\nFROM authors a\nLEFT JOIN books b ON a.author_id = b.author_id\nGROUP BY a.author_id, a.name;\n\n# Query 3: Find overdue books\nSELECT m.name, b.title, br.due_date\nFROM members m\nJOIN borrowings br ON m.member_id = br.member_id\nJOIN books b ON br.book_id = b.book_id\nWHERE br.return_date IS NULL\nAND br.due_date < CURRENT_DATE;\n\n# Analyze each query and suggest improvements\n# Consider:\n# 1. Index usage\n# 2. Join order\n# 3. WHERE clause optimization\n# 4. Possible denormalization"
        },
        {
            "title": "Database Connection Handler",
            "description": "Create a database connection handler class that manages connections to different types of databases (MySQL, PostgreSQL, SQLite) using a common interface.",
            "hint": "Use the factory pattern to create appropriate database connections. Implement connection pooling and error handling.",
            "startingCode": "from abc import ABC, abstractmethod\nfrom typing import Any, List, Dict\n\nclass DatabaseConnection(ABC):\n    @abstractmethod\n    def connect(self) -> None:\n        pass\n    \n    @abstractmethod\n    def disconnect(self) -> None:\n        pass\n    \n    @abstractmethod\n    def execute_query(self, query: str, params: tuple = None) -> List[Any]:\n        pass\n\nclass MySQLConnection(DatabaseConnection):\n    def __init__(self, config: Dict[str, str]):\n        # Initialize MySQL connection parameters\n        pass\n    \n    def connect(self) -> None:\n        # Implement MySQL connection\n        pass\n    \n    # Implement other methods\n\nclass PostgreSQLConnection(DatabaseConnection):\n    # Implement PostgreSQL connection handler\n    pass\n\nclass SQLiteConnection(DatabaseConnection):\n    # Implement SQLite connection handler\n    pass\n\nclass DatabaseFactory:\n    @staticmethod\n    def create_connection(db_type: str, config: Dict[str, str]) -> DatabaseConnection:\n        # Implement factory method\n        pass\n\n# Example usage\nif __name__ == \"__main__\":\n    # Create configuration\n    mysql_config = {\n        \"host\": \"localhost\",\n        \"user\": \"username\",\n        \"password\": \"password\",\n        \"database\": \"testdb\"\n    }\n    \n    # Create connection\n    db = DatabaseFactory.create_connection(\"mysql\", mysql_config)\n    \n    try:\n        # Use the connection\n        db.connect()\n        results = db.execute_query(\"SELECT * FROM users LIMIT 5\")\n        print(results)\n    finally:\n        db.disconnect()"
        }
    ]
}