{
    "title": "PostgreSQL Database",
    "content": "<h2>PostgreSQL Database in Python</h2><p>PostgreSQL is a powerful, open-source object-relational database system with a strong reputation for reliability, feature robustness, and performance. This lesson covers using PostgreSQL with Python through the psycopg2 library.</p><h3>1. Setting Up PostgreSQL</h3><h4>Installing psycopg2</h4><pre><code># Install psycopg2\npip install psycopg2-binary</code></pre><h4>Advanced PostgreSQL Features</h4><ul><li><strong>JSON Support</strong>: Native JSON and JSONB data types</li><li><strong>Array Types</strong>: Native array data types</li><li><strong>Custom Types</strong>: User-defined data types</li><li><strong>Full-Text Search</strong>: Advanced text search capabilities</li><li><strong>Inheritance</strong>: Table inheritance</li></ul><h3>2. Working with PostgreSQL</h3><h4>Connecting to PostgreSQL</h4><pre><code>import psycopg2\n\n# Establish connection\nconn = psycopg2.connect(\n    host=\"localhost\",\n    database=\"mydatabase\",\n    user=\"username\",\n    password=\"password\"\n)\n\n# Create a cursor object\ncur = conn.cursor()\n\n# Always close cursor and connection\ncur.close()\nconn.close()</code></pre><h4>Working with JSON Data</h4><pre><code>import psycopg2\nimport json\n\nconn = psycopg2.connect(\"postgresql://username:password@localhost/mydatabase\")\ncur = conn.cursor()\n\n# Create table with JSONB\ncur.execute(\"\"\"\nCREATE TABLE IF NOT EXISTS user_profiles (\n    id SERIAL PRIMARY KEY,\n    profile JSONB\n)\n\"\"\")\n\n# Insert JSON data\nprofile_data = {\n    \"name\": \"John Doe\",\n    \"age\": 30,\n    \"interests\": [\"programming\", \"databases\", \"hiking\"]\n}\ncur.execute(\n    \"INSERT INTO user_profiles (profile) VALUES (%s)\",\n    (json.dumps(profile_data),)\n)\n\n# Query JSON data\ncur.execute(\"SELECT profile->>'name' as name FROM user_profiles\")\nresults = cur.fetchall()\n\nconn.commit()\ncur.close()\nconn.close()</code></pre><h4>Using Array Types</h4><pre><code>import psycopg2\nfrom psycopg2.extensions import register_adapter, AsIs\n\nconn = psycopg2.connect(\"postgresql://username:password@localhost/mydatabase\")\ncur = conn.cursor()\n\n# Create table with array\ncur.execute(\"\"\"\nCREATE TABLE IF NOT EXISTS products (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(100),\n    tags TEXT[]\n)\n\"\"\")\n\n# Insert array data\ncur.execute(\n    \"INSERT INTO products (name, tags) VALUES (%s, %s)\",\n    (\"Laptop\", [\"electronics\", \"computers\", \"portable\"])\n)\n\n# Query array data\ncur.execute(\"SELECT * FROM products WHERE 'electronics' = ANY(tags)\")\nresults = cur.fetchall()\n\nconn.commit()\ncur.close()\nconn.close()</code></pre><h4>Full-Text Search</h4><pre><code>import psycopg2\n\nconn = psycopg2.connect(\"postgresql://username:password@localhost/mydatabase\")\ncur = conn.cursor()\n\n# Create table with text search capabilities\ncur.execute(\"\"\"\nCREATE TABLE IF NOT EXISTS articles (\n    id SERIAL PRIMARY KEY,\n    title VARCHAR(200),\n    content TEXT,\n    search_vector TSVECTOR\n)\n\"\"\")\n\n# Create search index\ncur.execute(\"\"\"\nCREATE INDEX articles_search_idx ON articles USING GIN(search_vector)\n\"\"\")\n\n# Create trigger for automatic search vector update\ncur.execute(\"\"\"\nCREATE TRIGGER articles_search_update\n    BEFORE INSERT OR UPDATE ON articles\n    FOR EACH ROW\n    EXECUTE FUNCTION\n    tsvector_update_trigger(search_vector, 'pg_catalog.english', title, content)\n\"\"\")\n\n# Search articles\ncur.execute(\"\"\"\nSELECT title, ts_rank(search_vector, query) as rank\nFROM articles, to_tsquery('english', 'postgresql & database') query\nWHERE search_vector @@ query\nORDER BY rank DESC\n\"\"\")\n\nresults = cur.fetchall()\n\nconn.commit()\ncur.close()\nconn.close()</code></pre><h4>Advanced Transactions</h4><pre><code>import psycopg2\nimport psycopg2.extensions\n\nconn = psycopg2.connect(\"postgresql://username:password@localhost/mydatabase\")\n# Set isolation level\nconn.set_isolation_level(psycopg2.extensions.ISOLATION_LEVEL_SERIALIZABLE)\n\ncur = conn.cursor()\n\ntry:\n    # Complex transaction\n    cur.execute(\"BEGIN\")\n    \n    # Multiple operations\n    cur.execute(\"UPDATE accounts SET balance = balance - 100 WHERE id = 1\")\n    cur.execute(\"INSERT INTO transactions (account_id, amount) VALUES (1, -100)\")\n    cur.execute(\"UPDATE accounts SET balance = balance + 100 WHERE id = 2\")\n    cur.execute(\"INSERT INTO transactions (account_id, amount) VALUES (2, 100)\")\n    \n    # Commit transaction\n    conn.commit()\nexcept psycopg2.Error as e:\n    conn.rollback()\n    print(f\"Error: {e}\")\nfinally:\n    cur.close()\n    conn.close()</code></pre>",
    "exercises": [
        {
            "title": "Advanced Data Types Handler",
            "description": "Create a Python class that demonstrates working with PostgreSQL's advanced data types (JSON, Arrays, Custom Types). Implement methods to store and retrieve complex data structures.",
            "hint": "Use psycopg2's adaptation and type casting features. Remember to handle JSON serialization/deserialization properly.",
            "startingCode": "import psycopg2\nimport json\nfrom typing import List, Dict, Any\n\nclass PostgresDataHandler:\n    def __init__(self, connection_params: Dict[str, str]):\n        # Initialize connection\n        pass\n    \n    def setup_database(self):\n        # Create necessary tables with advanced data types\n        pass\n    \n    def store_json_data(self, data: Dict[str, Any]) -> int:\n        # Store JSON data and return ID\n        pass\n    \n    def store_array_data(self, name: str, tags: List[str]) -> int:\n        # Store array data and return ID\n        pass\n    \n    def query_json_field(self, field: str, value: Any) -> List[Dict[str, Any]]:\n        # Query based on JSON field\n        pass\n    \n    def query_array_contains(self, tags: List[str]) -> List[Dict[str, Any]]:\n        # Query based on array contents\n        pass\n    \n    def close(self):\n        # Close connection\n        pass\n\n# Example usage\nif __name__ == \"__main__\":\n    try:\n        # Connection parameters\n        params = {\n            \"host\": \"localhost\",\n            \"database\": \"testdb\",\n            \"user\": \"username\",\n            \"password\": \"password\"\n        }\n        \n        handler = PostgresDataHandler(params)\n        handler.setup_database()\n        \n        # Store JSON data\n        user_data = {\n            \"name\": \"John Doe\",\n            \"age\": 30,\n            \"preferences\": {\n                \"theme\": \"dark\",\n                \"notifications\": True\n            }\n        }\n        user_id = handler.store_json_data(user_data)\n        \n        # Store array data\n        product_id = handler.store_array_data(\n            \"Smartphone\",\n            [\"electronics\", \"mobile\", \"5G\"]\n        )\n        \n        # Query data\n        users = handler.query_json_field(\"age\", 30)\n        products = handler.query_array_contains([\"electronics\"])\n        \n        print(\"Users:\", users)\n        print(\"Products:\", products)\n        \n        handler.close()\n    except Exception as e:\n        print(f\"An error occurred: {e}\")"
        },
        {
            "title": "Full-Text Search Engine",
            "description": "Implement a search engine using PostgreSQL's full-text search capabilities. Include features for indexing documents, ranking results, and highlighting matches.",
            "hint": "Use tsvector and tsquery for text search. Consider using different language configurations and weight assignments for better results.",
            "startingCode": "import psycopg2\nfrom typing import List, Dict, Tuple\n\nclass SearchEngine:\n    def __init__(self, connection_params: Dict[str, str]):\n        # Initialize connection\n        pass\n    \n    def setup_search_tables(self):\n        # Create tables with full-text search capabilities\n        pass\n    \n    def index_document(self, title: str, content: str, metadata: Dict[str, Any]) -> int:\n        # Index a document for searching\n        pass\n    \n    def search(self, query: str, limit: int = 10) -> List[Dict[str, Any]]:\n        # Search documents and return ranked results\n        pass\n    \n    def highlight_matches(self, document_id: int, query: str) -> str:\n        # Highlight matching terms in the document\n        pass\n    \n    def close(self):\n        # Close connection\n        pass\n\n# Example usage\nif __name__ == \"__main__\":\n    try:\n        # Connection parameters\n        params = {\n            \"host\": \"localhost\",\n            \"database\": \"testdb\",\n            \"user\": \"username\",\n            \"password\": \"password\"\n        }\n        \n        search_engine = SearchEngine(params)\n        search_engine.setup_search_tables()\n        \n        # Index some documents\n        doc1_id = search_engine.index_document(\n            \"PostgreSQL Full-Text Search\",\n            \"PostgreSQL provides powerful full-text search capabilities...\",\n            {\"author\": \"John Doe\", \"date\": \"2024-01-01\"}\n        )\n        \n        doc2_id = search_engine.index_document(\n            \"Advanced Database Features\",\n            \"Modern databases offer various advanced features...\",\n            {\"author\": \"Jane Smith\", \"date\": \"2024-01-02\"}\n        )\n        \n        # Search documents\n        results = search_engine.search(\"postgresql search\")\n        \n        # Display results with highlights\n        for result in results:\n            print(f\"Title: {result['title']}\")\n            print(f\"Relevance: {result['rank']}\")\n            print(f\"Highlights: {search_engine.highlight_matches(result['id'], 'postgresql search')}\")\n            print()\n        \n        search_engine.close()\n    except Exception as e:\n        print(f\"An error occurred: {e}\")"
        },
        {
            "title": "Concurrent Transaction Manager",
            "description": "Create a transaction manager that handles concurrent database operations safely using PostgreSQL's advanced transaction features. Implement proper isolation levels and deadlock handling.",
            "hint": "Use appropriate isolation levels and implement retry logic for deadlock situations. Consider using advisory locks for custom locking schemes.",
            "startingCode": "import psycopg2\nimport time\nfrom typing import List, Dict, Any\nfrom contextlib import contextmanager\n\nclass TransactionManager:\n    def __init__(self, connection_params: Dict[str, str]):\n        # Initialize connection pool\n        pass\n    \n    @contextmanager\n    def transaction(self, isolation_level: str = 'SERIALIZABLE'):\n        # Handle transaction context\n        pass\n    \n    def execute_with_retry(self, operation: callable, max_retries: int = 3) -> Any:\n        # Execute operation with retry logic\n        pass\n    \n    def transfer_funds(self, from_account: int, to_account: int, amount: float) -> bool:\n        # Perform safe fund transfer\n        pass\n    \n    def process_batch_operations(self, operations: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n        # Process multiple operations concurrently\n        pass\n    \n    def acquire_lock(self, lock_id: int) -> bool:\n        # Implement advisory locking\n        pass\n    \n    def release_lock(self, lock_id: int) -> bool:\n        # Release advisory lock\n        pass\n    \n    def close(self):\n        # Close all connections\n        pass\n\n# Example usage\nif __name__ == \"__main__\":\n    try:\n        # Connection parameters\n        params = {\n            \"host\": \"localhost\",\n            \"database\": \"testdb\",\n            \"user\": \"username\",\n            \"password\": \"password\"\n        }\n        \n        manager = TransactionManager(params)\n        \n        # Example concurrent operations\n        operations = [\n            {\"type\": \"transfer\", \"from\": 1, \"to\": 2, \"amount\": 100},\n            {\"type\": \"transfer\", \"from\": 2, \"to\": 3, \"amount\": 50},\n            {\"type\": \"transfer\", \"from\": 3, \"to\": 1, \"amount\": 75}\n        ]\n        \n        # Process operations\n        results = manager.process_batch_operations(operations)\n        \n        # Display results\n        for result in results:\n            print(f\"Operation status: {result['status']}\")\n            if 'error' in result:\n                print(f\"Error: {result['error']}\")\n        \n        manager.close()\n    except Exception as e:\n        print(f\"An error occurred: {e}\")"
        }
    ]
} 